#pragma once

//------------------------------

#define TOKENS_(...) std::initializer_list <TokenType> (__VA_ARGS__)

#define COMMANDS_DEFINES_ \
ACD_ (push, TOKENS_ ({TokenType::Numeric | TokenType::Register}), "push <number/register> - push number value to stack", { if (nextArgType () == TokenType::Numeric ) push (nextStackValue ()); else push (regGetNumber (nextByte ()));                                                                                                       }) \
ACD_ (pop,  TOKENS_ ({TokenType::None    | TokenType::Register}), "pop <optional: register> - pop value from stack",     { stack_value_t value = popValue (); if (nextArgType () == TokenType::Register) regSet (nextByte (), value);                                                                                                         }) \
ACD_ (add,  TOKENS_ ({                                        }), "add - sum 2 top stack values",                        { double rgt = popNumber ();  double lft = popNumber ();   push (lft + rgt);                                                                                                                                         }) \
ACD_ (sub,  TOKENS_ ({                                        }), "sub - subtract 2 top stack values",                   { double rgt = popNumber ();  double lft = popNumber ();   push (lft - rgt);                                                                                                                                         }) \
ACD_ (mul,  TOKENS_ ({                                        }), "mul - multiply 2 top stack values",                   { double rgt = popNumber ();  double lft = popNumber ();   push (lft * rgt);                                                                                                                                         }) \
ACD_ (div,  TOKENS_ ({                                        }), "div - divide 2 top stack values",                     { double rgt = popNumber ();  double lft = popNumber ();   if (rgt == 0) { error ("Zero division"); throw processor_error ("Zero division"); }  push (lft / rgt);                                                    }) \
ACD_ (in,   TOKENS_ ({                                        }), "in - push number value from program input",           { output ("Enter value: "); push (std::stod (input ()));                                                                                                                                                             }) \
ACD_ (out,  TOKENS_ ({                                        }), "out - pop and print number value",                    { output ("%lf\n", popNumber ());                                                                                                                                                                                    }) \
ACD_ (hlt,  TOKENS_ ({                                        }), "hlt - halt program",                                  {                                                                                                                                                                                                                    }) \
ACD_ (ver,  TOKENS_ ({                                        }), "ver - push assembler version to stack",               { push (static_cast <double> (ASSEMBLER_VERSION));                                                                                                                                                                   }) \
ACD_ (man,  TOKENS_ ({TokenType::Keyword                      }), "man <command> - print command manual",                { output ("%s\n", CommandManual (nextInstruction ()));                                                                                                                                                               }) \
ACD_ (hlp,  TOKENS_ ({                                        }), "hlp - print commands reference",                      { output ("Commands reference:\n"); for (size_t i = ByteCodesBegin; i < ByteCodesAmount; i++) output ("%s\n", CommandManual (static_cast <ByteCode> (i)));                                                           }) \
ACD_ (ret,  TOKENS_ ({                                        }), "ret - set top stack value as program return value",   { setReturnValue (popNumber ());                                                                                                                                                                                     }) \
ACD_ (dup,  TOKENS_ ({                                        }), "dup - duplicate top stack value",                     { push (top ());                                                                                                                                                                                                     }) \
ACD_ (dreg, TOKENS_ ({                                        }), "dreg - dump registers",                               { output ("Registers dump:\n"); for (size_t i = 0; i < REGISTERS_COUNT; i++) output ("  %s: 0x%0*X (%lf)\n", StrRegisterIndex (i), sizeof (stack_value_t)*2, regGetStackValue (i), regGetNumber (i)); output ("\n"); }) \
ACD_ (dstk, TOKENS_ ({                                        }), "dstk - dump stack",                                   { output ("Stack dump:\n"); for (size_t i = 0; i < m_stack.size (); i++) output ("  0x%0*X [%lf]\n", sizeof (stack_value_t)*2, m_stack[i], static_cast <double> (m_stack[i]) / NUMBERS_MODIFIER);     output ("\n"); }) \
ACD_ (jmp,  TOKENS_ ({TokenType::Numeric | TokenType::Register}), "jmp <number/register> - jump to address",             { jump (static_cast <uintptr_t> (nextArgType () == TokenType::Register? regGetNumber (nextByte ()): nextStackValue () / NUMBERS_MODIFIER));                                                                          }) \
ACD_ (sqr,  TOKENS_ ({                                        }), "sqr - square top stack value",                        { double number = popNumber (); push (number*number);                                                                                                                                                                }) \
ACD_ (sqrt, TOKENS_ ({                                        }), "sqrt - square root from top stack value",             { double number = popNumber (); push (static_cast <double> (sqrt (number)));                                                                                                                                         }) \
ACD_ (sin,  TOKENS_ ({                                        }), "sin - sin function of top stack value as angle",      { push (sin (popNumber ()));                                                                                                                                                                                         }) \
ACD_ (cos,  TOKENS_ ({                                        }), "cos - cos function of top stack value as angle",      { push (cos (popNumber ()));                                                                                                                                                                                         }) 

//------------------------------
